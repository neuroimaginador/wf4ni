---
title: "Using `wf4ni` to Build a Volumetry Flow"
author: "Domingo López-Rodríguez"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
 %\VignetteIndexEntry{Using `wf4ni` to Build a Volumetry Flow}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = nzchar(Sys.getenv("MY_EVAL_VARIABLE"))
)
```

```{r echo = FALSE}
resources_folder <- "./resources"
```


# Objective

# Requirements

## Packages

```{r messages = FALSE, warning=FALSE}
library(wf4ni)
```

```{r echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
library(ANTsRCore)
library(ANTsR)
library(extrantsr)
library(neurobase)
library(oro.nifti)
library(fslr)
```


## Other Resources

# Volumetry

```{r v_flow}
volumetry_flow <- NIflow$new(name = "volumetry",
                             work_dir = "~/flow/volumetry",
                             inputs = "T1")
```


## Register to Template Space

```{r reg_to_template}
# - register to a template (MNI152 in case of structural imaging)
# Returns the transformation, as declared in the ANTsRCore package
register_to_template <- function(image, template) {

  image <- check_ants(image)

  template <- check_ants(template)

  transform <- antsRegistration(fixed = template,
                                moving = image,
                                typeofTransform = "AffineFast",
                                verbose = TRUE)

  return(transform)

}


# Returns the image reoriented in the template space
get_img_in_template <- function(tx) {

  check_nifti(tx$warpedmovout)

}

# Returns the affine transformation
get_tx_to_template <- function(tx) {

  matrix(extrantsr::read_transformlist(tx$fwdtransforms)[[1]]$AffineTransform.float.3.3[1:9],
         nrow = 3, ncol = 3)

}

# Returns the scale parameter as the determinant of the affine transformation
get_scale_parameter <- function(M) {

  det(M)

}
```

```{r template}
template <- file.path(".", "resources",
                      "volumetry", "MNI152_T1_1mm.nii.gz")
```


```{r reg_to_template_flow}
volumetry_flow$add(what = register_to_template,
                   inputs = "T1",
                   output = "transformation",
                   template = template)

volumetry_flow$add(what = get_img_in_template,
                   inputs = "transformation",
                   output = "T1_MNI")

volumetry_flow$add(what = get_tx_to_template,
                   inputs = "transformation",
                   output = "affine_transform")

volumetry_flow$add(what = get_scale_parameter,
                   inputs = "affine_transform",
                   output = "scale_parameter")
```

Alternatively, one could simply use the `%>%` (pipe) operator to concatenate the operations, as follows:

```{r reg_to_template_flow_alt, echo = TRUE, eval = FALSE}
volumetry_flow  %>% 
  add(what = register_to_template,
      inputs = "T1",
      output = "transformation",
      template = template) %>% 
  add(what = get_img_in_template,
      inputs = "transformation",
      output = "T1_MNI") %>% 
  add(what = get_tx_to_template,
      inputs = "transformation",
      output = "affine_transform") %>% 
  add(what = get_scale_parameter,
      inputs = "affine_transform",
      output = "scale_parameter")
```

## Bias Field Correction

```{r bfc}
# - bias field correction, just a simple wrapper around
# n4BiasFieldCorrection
bfc <- function(img) {

  image2 <- as.antsImage(img)

  image2 <- n4BiasFieldCorrection(img = image2, verbose = TRUE)

  return(ants2oro(image2, reference = img))

}
```

```{r bfc_flow}
volumetry_flow$add(what = bfc,
                   inputs = "T1_MNI",
                   output = "T1_bfc")
```

## Brain Extraction

```{r bet}
# - brain extraction
# Uses MALF technique with a "brain extraction" dataset
# Returns the brain mask
make_brain_extraction <- function(image, 
                                  template_images, 
                                  template_structs) {

  my_image <- checkimg(image)

  res <- malf(infile = my_image,
              template.images = template_images,
              template.structs = template_structs,
              typeofTransform = "SyN",
              verbose = FALSE)

  return(res)

}
```

```{r template_images}
template_folder <- file.path(".", "resources", "volumetry", "bet")
template_images_bet <- list.files(path = file.path(template_folder,
                                               "images"),
                              pattern = ".nii.gz",
                              full.names = TRUE)
template_structs_bet <- list.files(path = file.path(template_folder,
                                               "masks"),
                              pattern = ".nii.gz",
                              full.names = TRUE)
```


```{r bet_flow}
volumetry_flow$add(what = make_brain_extraction,
                   inputs = "T1_bfc",
                   output = "brain_mask",
                   template_images = template_images_bet,
                   template_structs = template_structs_bet)

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("T1_bfc", "brain_mask"),
                   output = "betted")

```


## Segmentation

```{r aux_seg}
# - segmentation (GM, WM an CSF)
# Uses FSL's FAST tool to find a segmentation into GM, WM and CSF
# Returns the segmentation as a labelled image with labels 0 (background),
# 1 (CSF), 2 (GM) and 3 (WM)
get_segmentation <- function(img, mask = NULL) {

  if (!is.null(mask)) {

    input <- img
    input[mask == 0] <- 0

  } else {

    input <- img

  }

  my_file <- tempimg(input)

  res_file <- fsl_fast_nobias(file = my_file, retimg = TRUE)

  res_file <- gsub(pattern = ".nii.gz",
                   replacement = "",
                   x = res_file)

  res_file <- paste0(res_file, "_pveseg.nii.gz")

  return(check_nifti(res_file))

}
```

```{r flow_seg}
volumetry_flow$add(what = get_segmentation,
                   inputs = "betted",
                   output = "segmentation")
```

## Anatomical Parcellation

```{r aux_preproc}
# Remaps labels given by values = (l1, l2, l3, ...) present in the image img
# to numbers (1, 2, 3, ...) to make MALF easier.
remap_labels <- function(img, values = NULL) {

  if (is.null(values)) {

    values <- img %>% as.vector() %>% unique() %>% sort()
    values <- values[values > 0]

  }

  res <- 0 * img

  for (k in seq_along(values)) {

    res[img == values[k]] <- k

  }

  return(res)

}
```


```{r aux_parc}
# - parcellation
# Uses MALF technique with a previously labelled dataset
make_subcortical_parcellation <- function(image,
                                          mask = NULL,
                                          template_images,
                                          template_structs) {

  num_subjects <- length(template_images)

  # Subcortical structures labels
  retain_structs <- c(10, 11, 12, 13, 17, 18, 49:54)

  # Read label images
  out <- lapply(template_structs, readnii)
  out1 <- out[[1]]

  # Remap subcortical labels to 1, 2, ...
  out2 <- lapply(out,
                 function(s) remap_labels(s@.Data,
                                          values = retain_structs))

  # Save the remapped images to file
  my_outputs <- sapply(seq(num_subjects),
                       function(i) {

                         out1@.Data <- out2[[i]]

                         tempimg(nim = out1)

                       })

  if (!is.null(mask)) {

    input <- image
    input[mask == 0] <- 0

  } else {

    input <- image

  }

  # Apply MALF
  res <- malf(infile = input,
                         template.images = template_images,
                         template.structs = my_outputs,
                         typeofTransform = "SyN",
                         verbose = FALSE)

  return(res)

}

# Removes CSF voxels from the parcellation
refine_parcellation <- function(parcellation, segmentation) {

  parcellation[segmentation <= 1] <- 0

  return(parcellation)

}
```


```{r templates_parc}
template_folder <- file.path(".", "resources", "volumetry", "parcellation")
template_images_parc <- list.files(path = file.path(template_folder,
                                               "images"),
                              pattern = ".nii.gz",
                              full.names = TRUE)
template_structs_parc <- list.files(path = file.path(template_folder,
                                               "masks"),
                              pattern = ".nii.gz",
                              full.names = TRUE)
```


```{r flow_parc}
volumetry_flow$add(what = make_subcortical_parcellation,
                   inputs = "betted",
                   output = "parcellation_basic",
                   template_images = template_images_parc,
                   template_structs = template_structs_parc)

volumetry_flow$add(what = refine_parcellation,
                   inputs = c("parcellation_basic", "segmentation"),
                   output = "parcellation")
```

## Quantification

```{r aux_quant}
count_by_ROI <- function(img) {

  v <- img %>% as.vector()
  table(v[v > 0])

}
```


```{r flow_quant}
volumetry_flow$add(what = count_by_ROI,
                   inputs = "brain_mask",
                   output = "brain_volume_mni")

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("brain_volume_mni", "scale_parameter"),
                   output = "brain_volume")

volumetry_flow$add(what = count_by_ROI,
                   inputs = "segmentation",
                   output = "basic_volumetry_mni")

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("basic_volumetry_mni", "scale_parameter"),
                   output = "basic_volumetry")

volumetry_flow$add(what = count_by_ROI,
                   inputs = "parcellation",
                   output = "final_volumetry_mni")

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("final_volumetry_mni", "scale_parameter"),
                   output = "final_volumetry")
```

# Final Flow

```{r flow_plot, echo=TRUE, fig.show='asis', fig.width = 7, fig.asp = 1}
volumetry_flow$plot()
```

# Example

## Code

```{r example, eval = FALSE}
# Load data of the brain extraction dataset
problem <- "brain_extraction"
problem_path <- problem %>% get_dataset()

t1_dir <- file.path(problem_path, "inputs", "T1")
t1_files <- list.files(path = t1_dir, pattern = ".nii", full.names = TRUE)

res <- volumetry_flow$compute(what = c("T1_bfc",
                                       "brain_mask",
                                       "segmentation",
                                       "parcellation",
                                       "brain_volume",
                                       "basic_volumetry",
                                       "final_volumetry"),
                              from = list(T1 = t1_files[length(t1_files)]))

```

## Results

```{r res, eval = FALSE}
names(res$brain_volume) <- c("brain_volume")
res$brain_volume
```

```{r echo = FALSE}
readRDS(file = "./resources/brain_volume.rds")
```


```{r, eval = FALSE}
names(res$basic_volumetry) <- c("CSF", "GM", "WM")
res$basic_volumetry
```

```{r echo = FALSE}
readRDS(file = "./resources/basic_volumetry.rds")
```


```{r, eval = FALSE}
names(res$final_volumetry) <- c("left thalamus proper",
                                "left caudate", "left putamen", 
                                "left pallidum", "left hippocampus", 
                                "left amygdala", "right thalamus proper",
                                "right caudate", "right putamen", 
                                "right pallidum", "right hippocampus", 
                                "right amygdala")

res$final_volumetry
```

```{r echo = FALSE}
readRDS(file = "./resources/final_volumetry.rds")
```

## Images

```{r aux_plot_overlay}
plot_overlay <- function(image, overlay, text = "") {
  
  label_ids <- overlay %>% as.vector() %>% unique() %>% sort()
  label_ids <- label_ids[-1]
  overlay <- remap_labels(img = overlay)
  
  num_classes <- length(label_ids) + 1
  col.y <- scales::alpha(colour = scales::hue_pal()(num_classes), alpha = 0.45)
  
  if (num_classes == 4)
    col.y <- scales::alpha(colour = scales::viridis_pal()(num_classes), alpha = 0.3)
  
  ortho2(x = image, y = overlay, col.y = col.y, text = text)
  
}
```

```{r eval = FALSE}
plot_overlay(image = res$T1_bfc,
             overlay = res$brain_mask,
             text = "Brain Mask")
```

```{r, out.width = 700, fig.asp = 1, eval = TRUE, echo = FALSE}
knitr::include_graphics(path = "./img/vol_brain_mask.png")
```


```{r eval = FALSE}
plot_overlay(image = res$T1_bfc,
             overlay = res$segmentation,
             text = "Segmentation")
```

```{r, out.width = 700, fig.asp = 1, eval = TRUE, echo = FALSE}
knitr::include_graphics(path = "./img/vol_segmentation.png")
```

```{r eval = FALSE}
plot_overlay(image = res$T1_bfc,
             overlay = res$parcellation,
             text = "Parcellation")
```

```{r, out.width = 700, fig.asp = 1, eval = TRUE, echo = FALSE}
knitr::include_graphics(path = "./img/vol.parcellation.png")
```

## Full Flow Log

```{r print_log, eval = FALSE}
volumetry_flow$print_log()
```
```{r echo=FALSE, message=FALSE, warning=FALSE}
lines <- readLines(con = "./resources/vol_log.txt")

cat(lines, sep = "\n")
```


# Availability
