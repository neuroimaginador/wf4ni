---
title: "Using `wf4ni` to Build a Volumetry Flow"
author: "Domingo López-Rodríguez"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
 %\VignetteIndexEntry{Using `wf4ni` to Build a Volumetry Flow}
 %\VignetteEngine{knitr::rmarkdown}
 %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = nzchar(Sys.getenv("MY_EVAL_VARIABLE"))
)

library(wf4ni)
library(tidyverse)

```

# Objective

# Requirements

## Packages

## Other Resources

# Segmentation

## Preprocessing

### Auxiliary Functions

```{r aux_preproc}

num_subjects <- 4

remap_labels <- function(img, values = NULL) {

  if (is.null(values)) {

    values <- img %>% as.vector() %>% unique() %>% sort()
    values <- values[values > 0]

  }

  res <- 0 * img

  for (k in seq_along(values)) {

    res[img == values[k]] <- k

  }

  return(res)

}

get_as_antsImage <- function(img) {

  suppressPackageStartupMessages(library(ANTsR))
  suppressPackageStartupMessages(library(neurobase))

  if (is.character(img) && file.exists(img)) {

    return(antsImageRead(img))

  }

  if (is.antsImage(img)) {

    return(img)

  }

  if (is.nifti(img)) {

    my_file <- neurobase::tempimg(img)

    return(antsImageRead(my_file))

  }

}

get_as_nifti <- function(img) {

  library(ANTsR)
  library(neurobase)

  if (is.character(img) && file.exists(img)) {

    return(readnii(img))

  }

  if (is.antsImage(img)) {

    my_file <- tempfile(fileext = ".nii.gz")
    antsImageWrite(image = img, filename = my_file)

    return(readnii(my_file))

  }

  if (is.nifti(img)) {

    return(img)

  }

}

# - register to a template (MNI152 in case of structural imaging)
# Returns the transformation, as declared in the ANTsRCore package
register_to_template <- function(image, atlas_name) {
  
  suppressPackageStartupMessages(require(ANTsRCore))
  suppressPackageStartupMessages(require(ANTsR))
  suppressPackageStartupMessages(require(extrantsr))
  
  image <- get_as_antsImage(image)
  
  template <- get_as_antsImage(get_atlas(atlas_name))
  
  transform <- antsRegistration(fixed = template,
                                moving = image,
                                typeofTransform = "AffineFast",
                                verbose = TRUE)
  
  return(transform)
  
}


# Returns the image reoriented in the template space
get_img_in_template <- function(tx) {

  check_nifti(tx$warpedmovout)

}

# Returns the affine transformation
get_tx_to_template <- function(tx) {

  matrix(extrantsr::read_transformlist(tx$fwdtransforms)[[1]]$AffineTransform.float.3.3[1:9],
         nrow = 3, ncol = 3)

}

# Returns the scale parameter as the determinant of the affine trasnformation
get_scale_parameter <- function(M) {

  det(M)

}

# - bias field correction, just a simple wrapper around
# n4BiasFieldCorrection
bfc <- function(img) {

  image2 <- as.antsImage(img)

  image2 <- ANTsRCore::n4BiasFieldCorrection(img = image2, verbose = TRUE)

  return(ants2oro(image2, reference = img))

}

# - brain extraction
# Uses MALF technique with a "brain extraction" dataset
# Returns the brain mask
make_brain_extraction <- function(image, num_subjects = NULL) {

  problem <- "brain_extraction"
  problem_path <- problem %>% get_dataset()

  inputs <- list.files(file.path(problem_path, "inputs", "T1"), full.names = TRUE)
  outputs <- list.files(file.path(problem_path, "outputs"), full.names = TRUE)

  if (!is.null(num_subjects) && is.numeric(num_subjects)) {

    inputs <- inputs[seq(num_subjects)]
    outputs <- outputs[seq(num_subjects)]

  } else {

    num_subjects <- length(inputs)

  }

  res <- extrantsr::malf(infile = image,
                         template.images = inputs,
                         template.structs = outputs,
                         typeofTransform = "SyN",
                         verbose = FALSE)

  return(res)

}

```

### Flow code

```{r flow_preproc}
volumetry_flow <- NIflow$new(name = "volumetry",
                             inputs = "T1")

volumetry_flow$add(what = register_to_template,
                   inputs = "T1",
                   output = "transformation",
                   atlas_name = "MNI152_T1")

volumetry_flow$add(what = get_img_in_template,
                   inputs = "transformation",
                   output = "T1_MNI")

volumetry_flow$add(what = get_tx_to_template,
                   inputs = "transformation",
                   output = "affine_transform")

volumetry_flow$add(what = get_scale_parameter,
                   inputs = "affine_transform",
                   output = "scale_parameter")

volumetry_flow$add(what = bfc,
                   inputs = "T1_MNI",
                   output = "T1_bfc")

volumetry_flow$add(what = make_brain_extraction,
                   inputs = "T1_bfc",
                   output = "brain_mask",
                   num_subjects = num_subjects)

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("T1_bfc", "brain_mask"),
                   output = "betted")

```

Alternatively, one could simply use the `%>%` (pipe) operator to concatenate the operations, as follows:

```{r flow_preproc_alt, echo = TRUE, eval = FALSE}
volumetry_flow <- NIflow$new(name = "volumetry",
                             inputs = "T1") %>% 
  add(what = register_to_template,
      inputs = "T1",
      output = "transformation",
      atlas_name = "MNI152_T1") %>% 
  add(what = get_img_in_template,
      inputs = "transformation",
      output = "T1_MNI") %>% 
  add(what = get_tx_to_template,
      inputs = "transformation",
      output = "affine_transform") %>% 
  add(what = get_scale_parameter,
      inputs = "affine_transform",
      output = "scale_parameter") %>% 
  add(what = bfc,
      inputs = "T1_MNI",
      output = "T1_bfc") %>% 
  add(what = make_brain_extraction,
      inputs = "T1_bfc",
      output = "brain_mask",
      num_subjects = 5) %>% 
  add(what = function(A, B) {A * B},
      inputs = c("T1_bfc", "brain_mask"),
      output = "betted")
```


## Processing

### Auxiliary Functions

```{r aux_seg}
# - segmentation (GM, WM an CSF)
# Uses FSL's FAST tool to find a segmentation into GM, WM and CSF
# Returns the segmentation as a labelled image with labels 0 (background),
# 1 (CSF), 2 (GM) and 3 (WM)
get_segmentation <- function(img, mask = NULL) {

  if (!is.null(mask)) {

    input <- img
    input[mask == 0] <- 0

  } else {

    input <- img

  }

  my_file <- tempimg(input)

  res_file <- fslr::fsl_fast_nobias(file = my_file, retimg = TRUE)

  res_file <- gsub(pattern = ".nii.gz",
                   replacement = "",
                   x = res_file)

  res_file <- paste0(res_file, "_pveseg.nii.gz")

  return(check_nifti(res_file))

}

```

### Flow code

```{r flow_seg}
volumetry_flow$add(what = get_segmentation,
                   inputs = "betted",
                   output = "segmentation")

```


# Parcellation

## Auxiliary Functions

```{r aux_parc}
# - parcellation
# Uses MALF technique with a previously labelled dataset
make_subcortical_parcellation <- function(image, mask = NULL,
                                          num_subjects = NULL) {
  
  problem <- "parcellation"
  problem_path <- problem %>% get_dataset()
  
  inputs <- list.files(file.path(problem_path, "inputs", "T1"), full.names = TRUE)
  outputs <- list.files(file.path(problem_path, "outputs", "original"), full.names = TRUE)
  
  if (!is.null(num_subjects) && is.numeric(num_subjects)) {
    
    inputs <- inputs[seq(num_subjects)]
    outputs <- outputs[seq(num_subjects)]
    
  } else {
    
    num_subjects <- length(inputs)
    
  }
  
  # Subcortical structures labels
  retain_structs <- c(10, 11, 12, 13, 17, 18, 49:54)
  
  out <- lapply(outputs, readnii) #read_nifti_batch_4d(outputs)
  out1 <- out[[1]]
  
  out2 <- lapply(out, 
                 function(s) remap_labels(s@.Data, 
                                          values = retain_structs))
  
  my_outputs <- sapply(seq(num_subjects),
                       function(i) {
                         
                         out1@.Data <- out2[[i]]
                         
                         tempimg(nim = out1)
                         
                       })
  
  if (!is.null(mask)) {
    
    input <- image
    input[mask == 0] <- 0
    
  } else {
    
    input <- image
    
  }
  
  
  res <- extrantsr::malf(infile = input,
                         template.images = inputs,
                         template.structs = my_outputs,
                         typeofTransform = "SyN",
                         verbose = FALSE)
  
  return(res)
  
}

# Removes CSF voxels from the parcellation
refine_parcellation <- function(parcellation, segmentation) {
  
  parcellation[segmentation <= 1] <- 0
  
  return(parcellation)
  
}

```


## Flow code

```{r flow_parc}
volumetry_flow$add(what = make_subcortical_parcellation,
                   inputs = "betted",
                   output = "parcellation_basic",
                   num_subjects = num_subjects)

volumetry_flow$add(what = refine_parcellation,
                   inputs = c("parcellation_basic", "segmentation"),
                   output = "parcellation")

```

# Quantification

## Auxiliary Functions

```{r aux_quant}
count_by_ROI <- function(img) {

  v <- img %>% as.vector() 
  table(v[v > 0])

}
```


## Flow code

```{r flow_quant}
volumetry_flow$add(what = count_by_ROI,
                   inputs = "brain_mask",
                   output = "brain_volume_mni")

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("brain_volume_mni", "scale_parameter"),
                   output = "brain_volume")

volumetry_flow$add(what = count_by_ROI,
                   inputs = "segmentation",
                   output = "basic_volumetry_mni")

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("basic_volumetry_mni", "scale_parameter"),
                   output = "basic_volumetry")

volumetry_flow$add(what = count_by_ROI,
                   inputs = "parcellation",
                   output = "final_volumetry_mni")

volumetry_flow$add(what = function(A, B) {A * B},
                   inputs = c("final_volumetry_mni", "scale_parameter"),
                   output = "final_volumetry")

```



# Final Flow

```{r flow_plot, echo=TRUE, fig.show='asis', fig.width = 7, fig.asp = 1}
volumetry_flow$plot()
```

# Example

## Code

```{r example}
# Load data of the brain extraction dataset
problem <- "brain_extraction"
problem_path <- problem %>% get_dataset()

t1_dir <- file.path(problem_path, "inputs", "T1")
t1_files <- list.files(path = t1_dir, pattern = ".nii", full.names = TRUE)

res <- volumetry_flow$compute(what = c("T1_bfc",
                                       "brain_mask",
                                       "segmentation",
                                       "parcellation",
                                       "brain_volume",
                                       "basic_volumetry",
                                       "final_volumetry"),
                              from = list(T1 = t1_files[length(t1_files)]))

```

## Results

```{r res}
names(res$brain_volume) <- c("brain_volume")
res$brain_volume

names(res$basic_volumetry) <- c("CSF", "GM", "WM")
res$basic_volumetry

names(res$final_volumetry) <- c("left thalamus proper",
                                "left caudate", "left putamen", 
                                "left pallidum", "left hippocampus", 
                                "left amygdala", "right thalamus proper",
                                "right caudate", "right putamen", 
                                "right pallidum", "right hippocampus", 
                                "right amygdala")

res$final_volumetry
```


## Images

```{r aux_plot_overlay}
plot_overlay <- function(image, overlay, text = "") {
  
  label_ids <- overlay %>% as.vector() %>% unique() %>% sort()
  label_ids <- label_ids[-1]
  overlay <- remap_labels(img = overlay)
  
  num_classes <- length(label_ids) + 1
  col.y <- scales::alpha(colour = scales::hue_pal()(num_classes), alpha = 0.45)
  
  if (num_classes == 4)
    col.y <- scales::alpha(colour = scales::viridis_pal()(num_classes), alpha = 0.3)
  
  ortho2(x = image, y = overlay, col.y = col.y, text = text)
  
}
```

```{r plot_overlay, fig.width=7, fig.asp=1}
plot_overlay(image = res$T1_bfc,
             overlay = res$brain_mask,
             text = "Brain Mask")

plot_overlay(image = res$T1_bfc,
             overlay = res$segmentation,
             text = "Segmentation")

plot_overlay(image = res$T1_bfc,
             overlay = res$parcellation,
             text = "Parcellation")

```

## Full Flow Log

```{r print_log}
volumetry_flow$print_log()
```


# Availability
